---
title: \20
layout: default
category: [clearloop, luna]
---

> 反思

linus 有句老话，talk is cheap, show me the code.

这句话不是瞎胡扯，也不总是对。

反复不停的表达，探讨，质疑，否定，旁敲侧击的去判断某些事，才能够到真正动手去做的地步。毫不犹豫地、仅凭直觉地动手去做某些事情，并且把它们做的很好，并不是运气好，也不是真的不曾犹豫过，真的全凭直觉，而是你在遇到这些事情之前自身的积累(即使是毫不相干的)，已经足以让你 '毫不犹豫'，在这些时候，我们自己甚至意识不到。

近日处在风口浪尖浪尖上的任正非也有句老话，慢就是稳，慢就是快。

一样，这句话不是瞎胡扯，也不总是对。慢就是慢，快就是快。

这些模糊不清的话语，总被拿来随意解释，至于它们没什么实际意思。从迷信到质疑，再到感同身受，也总要花上一些时间。

-

像夏天来临，

人们会一边感叹夏天到了，一边发牢骚说它不是记忆里的夏天。

暴雨来临，空调窜进了屋子，人们会说，这就是夏天啊。

到了夏末，人们会象征性的总结，这个夏天和记忆中的夏天是不同的，但它依旧是夏天。

-

文字无法清晰的表达出人们的感受，它们往往是谬误的。

但，总有人能用有限的文字去表达无限的感受，亦或是或脱离文字这种途径，通过其他的办法。

-

顿悟并不是明白了什么，以往从没有意识到的事情。

而是那些你反复相信，反复否定，又反复相信的东西 —— 你永远处在这个过程中，直到某一天，你理解了相信与否定的转换规律，根源问题?，它们对于你来说成了常态，倒是有些顿悟的味道。

-

还有一个有趣的事情是，布列松的那个决定性瞬间，除去拍摄照片这一过程，它是否能够脱离景象(客观的瞬间)，绑定到思维时间(主观的瞬间)的概念中。

话说昨天夜里我下楼拍照，出门就得到了一张颇为满意的照片，之后瞎胡溜了 1 个小时，再也没有拍任何东西，所有看到的，都比不上我一开始拍到的那个景象。

老实说，并不是确实没有能与之媲美的景象，如若我回家睡一觉，再下楼拍一次，我会再次得到一张完美无瑕的照片，与之前不同的。

想想那些现在还用胶片机，或是喜欢拍立得的那些朋友们，按下的快门时，他们的心情到底是怎样的？

-

“我发现有时我能够控制一个梦想，在入睡前指导自己，梦见一个特定的主题，有时候我又无法做到。最重要的是，你要先在梦里看到你的手，我努力做了很多次，有几次我成功了，而且我切实的在梦里看到了我的手。” ——  \<lucid dream\>

第二十周

像是 5 个月了，还不到半年。

也没什么可记的，至少今天没有描述愿景的欲望。

零碎的想法也不记了。

emmm，零碎的想法就比如…

twitter 有意向取消点赞按钮，隐藏关注，我也是这么认为的，它们没多少用途，朋友圈也觉得没啥用。

我一直很喜欢即刻的设计，很好的继承了 RSS 这个东西，只是把自定义内容限制到了这个 app 本身上，它是十分年轻化的，却也似乎终于年轻化，多少有些闭塞。

就比如你去搜 Rust 这门编程语言的社区，即刻里面是没有的，微博上全是广告，微信里除去一些没人说话的群，就是那些单向宣传的大号，知乎里面有 ‘圈子’，设计上多少有些偏僻(被忽略)，也全是零碎的东西，豆瓣小组老实说是不错的，但里面也不会有，你只能去找官方论坛，或者去找找国内的 Rust 组织。

当然，你可以在 reddit 上找到，twitter 或 medium 上，也能找到不少高质量的讨论。

国内的互联网 ‘媒体’ 全线阵亡，是这么回事，把 Rust 换成别的东西，'娱乐消遣' 性质没那么强，结果也不会差太远，懵懂不是纯真，知识不是智慧。

如若百度贴吧活了下来，上面或许也会有些有趣的东西，但还是难以避免的要承受难以承受的用户体验与五花八门的广告，什么样的互联网产品充斥着乱糟糟的广告(有序整洁的广告是合理的)与极差的用户体验，却依旧深受人们喜爱？

黄网罢~

这其中的原因到底是什么，与华为遇到的问题多少有些相似罢。

互联网若是会下沉，同样也会上升。

这周在 native 上写了应用框架和登录页面，包括用户系统的数据结构，后端的基本配置之类。

基本的三个 tab 是，”聊天”，”联系人”，”发现”，偏向 Messenger 的那种感觉，不过我把设置藏在的发现里，左上角不放东西，微信那样，微信还有个很好的地方是，消息通知会以聊天的形式发送个用户，这个是很有趣的。拿 reddit Apollo 或者 twitter 来比对，聊天是比邮箱更有趣的。

我认为即刻，豆瓣的公众领域很棒，但却很难获得，那种。。归属感，就是，别人的即刻，别人的豆瓣，别人的 xxx 什么的。

我认为内容上的输出本质上来源于思想的宣泄，最基本的是，你要告诉你的朋友某件事情，你要通过跟他说话，或者文字交流，或是各种奇奇怪怪的办法，当你身边没有合适的宣泄对象是，你会想办法去结识一些新的朋友(能够沟通或相互理解一些特殊的东西)，但这并不代表你与你身边的朋友变得势不两立，如果是一些合适的问题，与身边的朋友交流，是胜过去找新的朋友的。

'即刻、豆瓣' 就是这样，包括 (twitter, tumblr...)(给我的感觉)，他们过于公开、公众化，至于你在上面只能遇到些陌生人，即使你在上面表达的一些东西，你更希望你身边的朋友能看到，而不是陌生人。

我的办法是把即刻豆瓣的动态，小组系统，升华成博客系统，用 reddit 的帖子形式表现，再用微信的 '聊天与联系人为主的模式' 把它们串起来。

似乎算是终于用简单的话，解释这么几个月的思考。。。

对朋友圈使用的心得就是，上学的时候，身边的人都用 qq，我就经常发 qq 动态，实习的时候身边的同事们都用微信，我就没再怎么碰过 qq，经常发微信动态，这阵子在家呆着，不上学也不上班，qq 动态也不发，微信动态也不发，因为身边的只有父母。

一句话来讲，就是，熟人社交能够很好地诱发人们的真实创作(价值创造)欲望，表达欲望(我还有非常多的例子可以印证这句话，它能够有理有据地解释我自己的很多行为，不过这里就不多提啦，是不是对所有人来说，都是这样的，我也不知道，不过我相信这个道理)。

微信不好的地方是，加了很多好友后，多少有些懵逼，朋友圈不够朋友，如果没有加那么多好友，我也不知道朋友圈原来是这个样子的。

如果你几个很熟的朋友，都热衷 reddit、medium、github、twitter，你们会有很多高质量的沟通，最典型的就是 reddit 的 r/place 像素画运动。

-

文本编辑则是选择了 rich text，非常实用的功能，知乎的 ‘提问’ 里面也有这个东西，与 slack 手写 markdown 相比，对于手机来说，到底是方便些。

还有两个 features，无密码登录和加密通讯。

无密码登录用了区块链钱包的概念，用户第一次登录，只需要填写一个用户 id，手机会自动生成一个非对称的密钥对，私钥存在用户端，公钥发送到服务端验证身份。不需要微信登录，不需要绑定手机，不需要绑定邮箱，不需要填写密码。

坑人的地方在于，用户若是换了手机，或用别人的手机，是没办法登录账号的。补救措施是。。。绑定一下手机(可选)，在换设备或者跨平台的时候，用手机验证码添加或重置密钥，github ssh 有是这样的办法。

加密通讯则是参考了 telegram 的办法，用 Diffie-Hellman 进行密钥交换，用户聊天的原始信息不会经过服务器，只有聊天的对象才能够看到，emmm，魔法。这个比较坑的地方是，由于相关库不是很完善，我水平又比较渣，实现起来有点麻烦，基本的都做完了再做。

再写视图的时候，跑神把之前 sonata 里面那个不知道怎么办，又意识不到的问题解决了。

rust 是强类型语言，没办法像 javascript 那样轻松的构建拥有各种数据类型的 ‘对象’，而 lisp 标志性的 cons，大抵本身就是二叉树，一直下不去手写，到底是厚着脸皮不想用结构体和枚举，不想用 rust 的 std libiary，包括在没多少经验的情况下强行用 Lisp 的思维通过 Rust 实现 Lisp，无计可施跃然纸上。

lisp 由 cons 组成，每个 cons 中有两个元素，car 会出来第一个元素，cdr 代表第二个元素。

car 与 cdr 的意思是 —— "Contents of Address/Decrement Register"。

```lisp
(jokes
  ('有个关于-lisp-的著名冷笑话是这样的 'my-other-CAR-is-CDR)
  ('关于这个冷笑话还有一个冷笑话  'My-other-CAR-is-a-CADR-CDR-isnt-a-CAR-at-all)
)
```

hhhh

举个例子： `(0 1)` 是一个 cons，它的 car 是 "0"，他的 cdr 是 "1"。

我解析出来的 car，cdr 与 标准 lisp 中的 car cdr 不大一样。。。但也确实有那个意思，并且我可以在它的基础上构造标准 lisp 的 car cdr。

举个例子：`(0 1)` 是一个 cons，它的 car 是 "0 1"，car 是 ""，它 car 的 car，也就是 caar，是 0，car 的 cdr，也就是 cadr， 是 1。

```rust
// 这是 sonata 的一个测试文件。
use sonata::Cons;

#[test]
fn test_cons() {
    let stream = b"(: hello)";                             
    assert_eq!(b": hello", stream.car());
    assert_eq!(b":", stream.car().car());
    assert_eq!(b"hello", stream.car().cdr());
}

/// # 在 (: hello) 中，如何一下找出 : 与 hello ？
/// _可以根据长度和顺序直接判断_
/// + car  => : hello |   [0] 
/// + caar => :       |   [0, 0]
/// + cadr => hello   |   [0, 1] 
/// 
/// _还有一些空值的地方_
/// + cdr  => ""      |   [1]
/// + cdar => ""      |   [1, 0]
/// + cddr => ""      |   [1, 1]
```

其间的规律是：

+ (: hello) 是一个 cons。
  + 它有两个元素，分别是 ": hello" 与 ""。
  + 可以用 [0] 和 [0, 1] 来表示。
+ : hello 是一个 cons。
  + 它有两个元素，分别是 ':" 与 "hello"。
  + 可以用 [0, 0] 与 [0, 1] 来表示

从 (: hello) 中，我们可以直接看出来：
+ (: hello) 有两层 cons
+ (: hello) 的第二层 cons 的两个元素是 : 和 hello
+ (: hello) 没有第三层
+ : 可以用 [0, 0] 来表示，hello 可以用 [0, 1] 来表示


我们可以直接排除掉：[1]、[1, 0]、[1, 1]。

程序解析的时候也一样，不用去判断 [0]、[1]、[0, 0]、[0, 1]、[1, 0]、[1, 1]  ;;  6(2^1 + 2^2) 次。直接去找 [0, 0] 与 [0, 1] 就好了。

办法则是，程序会先去掉首位的 "(" 与 ')"，然后读到，": hello" 之间有 ":" 和 "hello" 其他的全是空白的，所以就分出来了 2 个元素，推理出来一共有 2 层 cons，6(2^2 + 2^1) 种排列办法，这两个 元素分别可以用 [0, 0] 与 [0, 1] 去表示。

如果 "()" 中有 3 个 "元素" 呢？ 那就是 [0, 0]、[0, 1, 0]、[0, 1, 1] 这三个。

如果 "()" 中有 4 个 "元素" 呢？[0, 0]、[0, 1, 0]、[0, 1, 1, 0]、[0, 1, 1, 1]。

再举个练习题。。。感兴趣的老铁可以自己感受下。

```rust
use sonata::Cons;

#[test]
fn test_list() {
    let stream = b"(: > !)";
    assert_eq!(b": > !", stream.car());           // car    => : > !  | [0]
    assert_eq!(b":", stream.car().car());         // caar   =>  :     | [0, 0] 
    assert_eq!(b"> !", stream.car().cdr());       // cadr   => > !    | [0, 1]
    assert_eq!(b">", stream.car().cdr().car());   // cadar  =>  >     | [0, 1, 0]
    assert_eq!(b"!", stream.car().cdr().cdr());   // caddr  =>  !     | [0, 1, 1] 
}
```

emmm，不用结构体，不用枚举，用数组的办法来表示某个数据的位置，到底是做到了。

其实是很典型的二叉树(Binary-Tree)应用。。。Binary-Tree 听起来就没有那么悬乎，因为 Binary 就是 0, 1，但二叉树听起来就像神仙，如果不是写 sonata，我估计老死也不会知道二叉树原来是小学奥数就学过的东西。。。

这种感觉就像，小学的时候，用圆规基于线段的黄金分割线不停的画圆那样，那个下午。喜欢摇滚乐的，早晚会与摇滚乐重逢，数学物理或许也一样。记得高中分文理科时也是这么想的，如果我真的能够理解数学与物理中的美，那么即使我学习文科，即使我考不上大学，一样会再遇到它们，在这样的前提下，文科当然是更好的选择。 —— 想的有点远了。

任何编程语言都可以用 cons 构造其他数据结构，不过在 lisp 中，它不仅可以构建其他数据结构，同样也构建了 lisp 本身，它可以表达一切。

Sonata 会衍生出一种 "可编程" 的数据结构，Stml。Sonata 与 Stml 的关系就像，Javascript 与 Json 的关系一样。

当然，做完社交媒体之前，是没心情写 Sonata 的，除非我得了堆视图就会躺在床上起不来的病。或许它终归只是一个玩具语言，或许它能够成为 Javascrpt 那样引领一个时代的语言。

不知道，也不关心。

会或者不会，也就 1/2 的概率罢。


> 后记

我不想成为职业程序员，想成为那种，在井市翻浪的那种游手好闲的家伙，无厘头地去谩骂那些我看不惯的人，看不惯的事情，看不惯的景象，去赞扬或者欣赏我觉得很棒的人、事情，一些景象。

但是我没办法，有什么东西总在推着我，那种厚实的，混沌又离散的尘雾，从身后裹住了我，我没办法向左走，也没办法向右走，后退更是不可能，如果我什么都不做，它只会一直将我往前推，直到生命的尽头。

若是我跑的足够快，我就能甩掉这裹尘雾，我可以自由的向左走，向右走，甚至是回到起点。

编程给我的感觉，就像是玩游戏，摇滚乐、写东西或者拍照。。。都一样。

那种你一放学回家就把自己闷在屋子玩的那种，吃饭的时候想着玩什么职业，睡觉的时候想着如何打怪升级，即使亲人朋友就在身边，也没办法阻止自己想这些东西。

与电子游戏相比。。。似乎也没什么区别，一旦中意上了某个游戏，只有玩通关了才有心情玩其他的游戏，在此期间，你只会在疲倦劳累的时候去碰一碰其他的。

也不知道到底是不是这么回事，但总有这种感觉。

有些关卡你喜欢，有些关卡你不喜欢，你可以去完成所有支线任务，也可忽略它们。

我时常想象视图的结果，但堆视图过程却总是让我殚精竭虑，太多的限制要参考，枯燥的要命，除非我一边喝酒一边去处理它们，就像蜡笔小新蒙上眼睛吃青椒的那种意向，生理上可以吃，但就是不想吃。

处理纯粹的逻辑问题倒没那么疲倦，没有那么多繁冗的人造限制，你可以基于对编程语言的掌握，去尝试解决任何问题，用美国队长的话就是，我可以像这样打上一整天。

vim 与 emacs 的关系也像是如此。

像喜欢那些画好了的画，自己动手尝试起来却十分枯燥无力，对照到这个问题上，与其去动手 "画画"，更偏好那些画为什么令人感到舒适，为什么它们是值得欣赏的，不同颜色会诱发出什么样的感官情绪，以及这些颜色产生的原理，去造能够方便自己画画的工具，去寻找不存在的颜色，去找到色彩与画作表达结果的规律，再运用这些规律去画出来属于自己的画，用来验证想法。因为我不是真的想 "画画"，我只想知道它们 "表达" 的原理，再动手验证一下，我的想法是否是正确的，如果它不正确，就继续验证，到正确了才行。

-

很多时候感受无法表达，并把责任推诿给了没有合适的表达对象上，这大抵是错误。

拿编程的例子来讲，与不了解编程的朋友谈论，总觉得委屈了他们，但即使与那些我遇到过的，富有编程经验的人来讨论，同样不觉得他们能够理解我的乐趣，就像是被夹在了太极图中间的那条线上，你没办法去白色的地方，也没办法去黑色的地方，只能在中间的线上抱头鼠窜，紧促，你不得不想办法从太极图中跳出来，可一旦你这么做，你只会离白色与黑色越来越远，这并不是你想要的结果。

或许注定呆在那条线上？又或许跳的足够高，就能够落到任何地方？

像上面提到的尘雾的那个感觉，不仅在时间线与生活上是这样，生活中的细节也不放过。

“我发现有时我能够控制一个梦想，在入睡前指导自己，梦见一个特定的主题，有时候我又无法做到。最重要的是，你要先在梦里看到你的手，我努力做了很多次，有几次我成功了，而且我切实的在梦里看到了我的手。”
