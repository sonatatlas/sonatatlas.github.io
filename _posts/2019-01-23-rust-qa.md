---
title: Rust Q&A
categories: back-pages
tags: rust
layout: default
---

# Std misc
Many other types are provided by the std library to support things such as:

+ Threads
+ Channels
+ File I/O

These expand beyond what the primitives provide.
## Threads
Rust provides a mechanism for spawning native OS threads via the spawn function, the argument of this function is a moving closure.
## Channels
Rust provides asynchronous channels for communication between threads. Channels allow a unidirectional flow of information between two end-points: the Sender and the Receiver.
## Path
The Path struct represents file paths in the underlying filesystem. There are two flavors of Path: posix::Path, for UNIX-like systems, and windows::Path, for Windows. The prelude exports the appropriate platform-specific Path variant.
## File I/O
The File struct represents a file that has been opened (it wraps a file descriptor), and gives read and/or write access to the underlying file.
## Child process
The process::Output struct represents the output of a finished child process, and the process::Command struct is a process builder.
## Filesystem Operations
The std::fs module contains several functions that deal with the filesystem.
## Program arguments
+ Standard Library

  The command line arguments can be accessed using std::env::args, which returns an iterator that yields a String for each argument.

+ Crates
  
  Alternatively, there are numerous crates that can provide extra functionality when creating command-line applications. The Rust Cookbook exhibits best practices on how to use one of the more popular command line argument crates, clap.

## Foreign Function Interface
Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign functions must be declared inside an extern block annotated with a #[link] attribute containing the name of the foreign library.

# 
-

# 01
## Show u8 slice in hex representation - [stackoverflow][s-1]

> convert each two bytes into [hex][r-1].
    
```rust
fn main() {
    // Template
    let bytes = [
        177, 147, 134, 198, 163, 82, 51, 22,
        41, 118, 161, 105, 142, 86, 191, 146,
        250, 11, 152, 10, 58, 75, 238, 24,
        21, 46, 68, 18, 3, 112, 162, 50,
    ];

    // String to extend.
    let mut hex = String::new();
    hex.extend(bytes.iter().map(|byte| format!("{:02x}", byte)));

    // Print it.
    println!("{:}", hex);
}
```

# 00
## Is it possible for one struct to extend an existing struct, keeping all the fields? - [stackoverflow][s-2]

> Implementing [Deref][r-2] for smart pointers that we can access the data behind, kind like inherit.
    
```rust
// Existing struct.
struct Person {
  gender: &'static str,
  age:    &'static i32
}

// Some struct new.
struct Child(Person);

// Implementing Deref.
impl std::ops::Deref for Child {
  type Target = Person;
  fn deref(&self) -> &Self -> &Self::Target {
    &self.0
  }
}

fn main() {
  let child = Child(Person{
    gender: "male",
    age:     6_i32
  });

  println!("your child is {}, {} years old.", child.gender, child.age);
}
```


<!-- rust docs -->
[r-1]: https://doc.rust-lang.org/std/fmt/index.html#width
[r-2]: https://doc.rust-lang.org/std/ops/trait.Deref.html

<!-- question links -->
[s-1]: https://stackoverflow.com/questions/27650312/show-u8-slice-in-hex-representation/54302798?noredirect=1#comment95439998_54302798
[s-2]: https://stackoverflow.com/questions/32552593/is-it-possible-for-one-struct-to-extend-an-existing-struct-keeping-all-the-fiel/54301034#54301034
